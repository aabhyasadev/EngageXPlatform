EngageX – Overall Platform Report
1. Overview
EngageX is a multi-tenant email marketing and engagement platform designed for organizations. It provides secure onboarding, domain authentication, flexible user management, contact handling, campaign execution, and post-campaign analytics.

2. Organization & User Management
Organization-Based Sign Up
A new organization registers on the platform.
The first user automatically becomes the Admin of that organization.
Each organization is assigned a unique Organization ID.


Admin Capabilities
Manage subscription (trial, monthly, yearly).
Set up and verify sending domains.
Add, remove, and manage users with role-based access.
Oversee campaigns and analytics for the entire organization.


User Login


Users log in with:
Organization ID
Username
Password


Optional Authentication: MFA, SSO, Phone OTP, Email OTP.


Multi-User Setup
Admin can create multiple users (Campaign Managers, Analysts, Editors).
Role-based permissions ensure data security and operational efficiency.


3. Onboarding & Authentication
Sign Up Flow
Enter Name & Phone → Personalize data (contacts_range, employees_range, industry).
Enter Email → Verify via OTP if not registered.
Create a strong password → Account created with Free Trial Plan activated.
If registered, redirect to Login / Password Reset.


Login Options
Organization ID
Username/Email + Password.
Optional: MFA, SSO, Phone OTP, Email OTP.



4.Domain Setup & Verification (Multi-Domain Support)
Organizations must authenticate each sending domain before launching campaigns. If multiple domains are used, repeat the steps for each domain.
Manual DNS setup required with records:
CNAME
DKIM
DMARC
TEXT


Verification improves sender reputation and email deliverability.

5. Subscription & Packages
Free Trial Plan is auto-activated on new account creation.
Organizations can upgrade to:
Monthly Plans
Yearly Plans
Plans unlock higher contact limits, campaign capacity, and advanced analytics.
6. Contact Management
Contact Handling


Add/Delete contacts individually.
Bulk upload via Excel (.xlsx).
Bulk or single contact editing:
Subscribe/Unsubscribe lists.
Update fields (Language, Account, Phone).


Segmentation
Create lists (groups).
Assign contacts to specific groups for targeted campaigns.

7. Campaign Creation Workflow
Campaign execution follows a structured process:
Sign Up / Login
|
+--> Add Domain
     |
     +--> Verify Domain
          |
          +--> (CNAME)
          +--> (DKIM)
          +--> (DMARC)
          +--> (TEXT)
|
+--> Upload Contacts
     |
     +--> Assign Contacts to Groups
|
+--> Create Campaign
     |
     +--> Select Contact Group
     |
     +--> Choose Sending Domain
     |
     +--> Send Email
            |
            +--> Immediate
            +--> Scheduled
|
+--> Track Results
       |
       +--> Opens
       +--> Clicks
       +--> Bounces
       +--> Unsubscribes


8. Email Template Creation
Template Creation Options
Drag-and-Drop Editor – Build templates visually without coding.
HTML Editor – Add custom-coded templates for advanced design control.
Clone & Edit – Duplicate past campaigns and repurpose them.
Default Templates
EngageX provides a library of pre-designed email templates (Newsletters, Announcements, Promotions, Transactional Emails).
Organizations can customize default templates with their branding (logo, color scheme, fonts).
Template Management
Save templates for reuse across campaigns.
Organize templates by categories (marketing, transactional, seasonal).
Assign template access based on user roles (e.g., Editors create, Analysts view only).

9. Tracking & Analytics
EngageX provides actionable insights after campaign execution:
Open Rate – measures engagement.
Click Rate – tracks link interactions.
Bounce Rate – detects failed deliveries.
Unsubscribe Rate – monitors audience churn.
10. Overall Benefits
Enterprise-Ready – Organization ID ensures isolated, secure environments.


Role-Based Access – Admins assign permissions to team members.


Scalability – From startups to large enterprises, multi-user, multi-domain support.


Data Security – MFA, OTP, and SSO protect user accounts.


High Deliverability – Verified domains boost trust and reduce spam.


Efficiency – Bulk contact management and smart campaign scheduling save time.



EngageX is not just an email marketing platform but a complete organizational communication and engagement system, tailored for enterprise scalability and security.









EngageX
Customer Engagement Focus
📌 Tech Stack Overview
Version Control: Git (VCS)
Collaboration & Hosting: GitHub
Repo Structure: Monorepo (frontend, backend, devops in a single repo)
Teams Setup (GitHub):
frontend-EngageX → UI/UX, React, Tailwind, Bootstrap, etc.
backend-EngageX → APIs, business logic, Django services
devops-EngageX → CI/CD, infra, monitoring, deployments
🌳 Branching Strategy (3-branch model)
Main:
Always production-ready
Deployment: Production environment
Protection: No direct push, PR required, CI/CD checks

Staging:
Pre-production testing / QA
Deployment: Staging environment
Protection: PR required from develop, CI/CD checks

Develop:
Active development branch

Monorepo Directory Structure
 EngegeX/
 ├── .github/   # GitHub Actions workflows, CODEOWNERS, PR/issue templates
 ├── backend/   # Backend (Django APIs, business logic, Python code)
 ├── devops/   # CI/CD, infra as code, deployment scripts
 ├── docs/     # Documentation (Markdown, Sphinx, etc.)
 ├── frontend/ # Frontend (React, Vite, TypeScript, Bootstrap, etc.)
 └── monitoring/ # Monitoring, logging, alert configs

🎨 Frontend Stack
Framework: React + Vite
Language: TypeScript
UI: Bootstrap, Redux for state management
Page/Template Builder: GrapesJS
Email Campaigns: React Email Editor

⚙️ Backend Stack
Language: Python
Framework: Django + Django REST Framework (DRF)
Asynchronous Tasks: Celery + Redis
Message Streaming: Kafka (Event-driven tasks & analytics pipelines)
API Layer: REST APIs for campaigns, contacts, analytics

🗄️ Databases & Search
PostgreSQL → Main relational database
Redis → Queues, caching, Celery task broker
Elasticsearch → Fast full-text search across contacts, campaigns, logs
Kafka → Event streaming platform for real-time pipelines

📊 Monitoring & Observability
Prometheus → Metrics collection
Grafana → Dashboards & visualization
Sentry → Real-time error tracking

🔄 CI/CD (GitHub Actions)
frontend-ci.yml → Build & test frontend
backend-ci.yml → Lint, migrations, Django tests
devops-ci.yml → Build & push Docker images
monitoring-ci.yml → Validate Prometheus/Grafana configs

📦 Docker Containers
Redis → Caching + Celery task broker
PostgreSQL → Main relational database (SSL + TLS enabled) x
Frontend → React + Vite + TypeScript, served via Nginx
Backend → Django + DRF APIs, connects to PostgreSQL, Redis, and Celery
Monitoring → Prometheus, Grafana, Sentry


🖥️ Server Architecture (Production)

                    ┌───────────────────────────┐
                    │        Client (Web)       │
                    │ React + Vite (TS, Redux)  │
                    └─────────────▲─────────────┘
                                  │
                        HTTPS / Nginx / CDN
                                  │
                    ┌─────────────┴─────────────┐
                    │    Application Layer      │
                    │ (Dockerized Services)     │
                    └─────────────┬─────────────┘
      ┌───────────────────────────────────────────────────┐
      │ Backend (Django + DRF)                            │
      │  - REST APIs                                      │
      │  - Auth / Campaigns / Contacts / Analytics        │
      └───────────────────────────────────────────────────┘
                  │
                  ▼
        ┌───────────────────────────────┐
        │ Celery Workers (Async Tasks)  │
        │ - Email sending               │
        │ - Bulk imports/exports        │
        │ - Analytics aggregation       │
        └───────────────────────────────┘
                  │
   ┌──────────────┼───────────────┐
   ▼              ▼               ▼
┌───────┐   ┌───────────┐   ┌─────────────┐
│Redis  │      │PostgreSQL │    │Elasticsearch│
│Cache +│      │Main DB    │    │Search index │
│Broker │      │Relational │    │Campaign logs│
└───────┘   └───────────┘   └─────────────┘

                  │
                  ▼
     ┌─────────────────────────────┐
      │ Monitoring & Observability  │
      │ - Prometheus (metrics)      │
      │ - Grafana (dashboards)      │
      │ - Sentry (errors)           │
     └─────────────────────────────┘







Security & Privacy Hardening (Server, Django, React, PostgreSQL)
This section provides concrete, copy-pastable baselines and checklists tailored to EngageX’s monorepo and stack.
1. Server / Edge (Nginx/CDN/WAF)
Goals: TLS everywhere, strict headers, sane limits, least privilege.
TLS: Enforce TLS 1.2+ (prefer 1.3), redirect HTTP→HTTPS, enable OCSP stapling.
HSTS: Preload with long max‑age after validating readiness.
WAF: Enable ModSecurity with OWASP CRS or use managed WAF (Cloudflare/AWS).
Rate limits: Per‑IP and per‑route (stronger on /api/auth/*, /api/webhooks/*).
CORS: Only allow the frontend origin(s); never * with credentials.
Cookies: Secure; HttpOnly; SameSite=Lax/Strict, scoped to correct domain.
Timeouts & sizes: Low client_body_timeout, client_max_body_size per route; smaller for auth/webhooks.
mTLS (optional): For internal services and admin endpoints.
Nginx security headers (baseline):
# In server {} or location /api/
add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
add_header X-Content-Type-Options "nosniff" always;
add_header Referrer-Policy "strict-origin-when-cross-origin" always;
add_header Permissions-Policy "geolocation=(), camera=(), microphone=(), payment=()" always;
add_header Cross-Origin-Opener-Policy "same-origin" always;
add_header Cross-Origin-Resource-Policy "same-origin" always;

# Prefer frame-ancestors over X-Frame-Optionsadd_header 
Content-Security-Policy "default-src 'self'; base-uri 'none'; 
object-src 'none'; frame-ancestors 'none'; form-action 'self'; 
upgrade-insecure-requests" always;

Nginx rate limiting example:
limit_req_zone $binary_remote_addr zone=perip:10m rate=100r/m;
limit_req_zone $binary_remote_addr zone=login:10m rate=10r/m;

location /api/auth/ {
  limit_req zone=login burst=20 nodelay;
  # proxy_pass ...
}
location /api/ {
  limit_req zone=perip burst=200;
}

2. Django/DRF Backend
Authentication & sessions
Prefer cookie-based auth (HttpOnly, Secure, SameSite=Lax/Strict) + Django CSRF middleware.
If using JWT (e.g., simplejwt), store in HttpOnly cookies, access token ≤10m, rotating refresh tokens with reuse detection, aud/iss set, jti tracked.
Always carry org_id in auth context and enforce in views/DB.
RBAC & multi‑tenant isolation
Permission classes check role AND org membership.
All queries are org‑filtered; use org‑aware managers.
Sensitive actions (exports, user invites) require admin scope and are audited.
Security settings (baseline):
# settings/base.py
SECURE_SSL_REDIRECT = True
SESSION_COOKIE_SECURE = True
SESSION_COOKIE_SAMESITE = "Lax"  # or "Strict" if UX allows
CSRF_COOKIE_SECURE = True
CSRF_COOKIE_SAMESITE = "Lax"
X_FRAME_OPTIONS = "DENY"
SECURE_REFERRER_POLICY = "strict-origin-when-cross-origin"
SECURE_BROWSER_XSS_FILTER = True  # legacy, harmless
SECURE_HSTS_SECONDS = 31536000
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
SECURE_HSTS_PRELOAD = True
REST_FRAMEWORK = {
  "DEFAULT_THROTTLE_RATES": {"anon": "60/min", "user": "600/min"},
}
CELERY_TASK_SERIALIZER = "json"
CELERY_ACCEPT_CONTENT = ["json"]
CELERY_RESULT_SERIALIZER = "json"
CSRF & CORS
CSRF middleware enabled; for SPA, use Double‑Submit Cookie or standard Django CSRF token.
CORS allowlist only (e.g., CORS_ALLOWED_ORIGINS = ["https://app.engagex.io"]).
Input/Output hardening
Validate payloads with DRF serializers; explicit allow‑lists.
Sanitize any HTML (templates) server‑side (e.g., bleach) with strict tags/attributes; never render raw user HTML.
Limit upload sizes, mime types; virus scan (ClamAV) async before use.
Avoid SSRF: do DNS-only checks for domain verification, never fetch arbitrary URLs; if fetching is needed, use allow‑lists and egress proxy with ACLs.
Webhooks
Verify provider signatures (HMAC/RSA), IP allowlist, constant‑time compare; idempotent handlers.
Respond 2xx quickly and process heavy work async.
Secrets & keys
Keep DKIM private keys encrypted (KMS) and masked in logs.
Use an environment/secret manager (e.g., Vault/SM) — never commit secrets.
Logging/observability
Structured JSON logs; redact tokens, cookies, emails; sample user IPs (or hash) for privacy.
Per‑tenant log labels; Sentry scrubbing rules for PII.
Dependencies
pip-audit, Bandit, Safety in CI; Dependabot for both Python and Node.

3 React Frontend (Vite/TS)
Auth & storage
Do not store tokens in localStorage/sessionStorage.
Use HttpOnly cookies; rely on CSRF token for state‑changing requests.
CSP & integrity
Strong CSP; only allow specific CDNs; use nonces for any inline scripts.
If loading third‑party scripts, use Subresource Integrity (SRI) attributes.
XSS/DOM safety
Avoid dangerouslySetInnerHTML. Where email/HTML preview is required, sanitize with DOMPurify (email‑safe profile) and disable scripts/JS URLs/styles as needed.
Encode all interpolations.
UX privacy
Don’t display raw email contents or PII in toast/errors; keep messages generic.
Mask secrets in forms.
Uploads
Client‑side size/type checks; use S3 presigned POSTs; never expose credentials.
Dependencies
Lockfile committed; npm audit in CI; restrict devtools in prod builds.

4. PostgreSQL (tenant isolation, encryption, audit)
Network & auth
Private subnet only; require TLS (sslmode=verify-full for clients).
Use scram-sha-256 auth; separate least‑privileged app role; no superuser in apps.
Row‑Level Security (RLS) pattern
-- Example for contacts table
ALTER TABLE contacts ENABLE ROW LEVEL SECURITY;

CREATE POLICY contacts_isolation ON contacts
  USING (org_id::text = current_setting('app.current_org_id', true));
Set org context per request (Django middleware):
from django.db import connection

class DBOrgContext:
    def __init__(self, get_response):
        self.get_response = get_response
    def __call__(self, request):
        org_id = getattr(request, "org_id", None)
        if org_id:
            with connection.cursor() as cur:
                cur.execute("SELECT set_config('app.current_org_id', %s, true)", [str(org_id)])
        return self.get_response(request)
Encryption
At rest: enable cloud disk encryption; encrypt backups; restrict backup access.
Column/field level for sensitive data (e.g., phone): pgcrypto or Django EncryptedFields.
Backups & DR
PITR enabled; regular restore tests; backups encrypted with KMS.
Audit & hygiene
pgaudit for DDL/DCL; minimize row‑level logging to avoid PII spillage.
Use pg_stat_statements; rotate logs; alert on failed auth spikes.
Performance & safety
pgbouncer (transaction pooling) with TLS; tight connection limits.
Partition large tables (campaign_sends/events) and set sensible retention.

5. Other Critical Components
Redis: TLS, ACLs, requirepass, private network; avoid storing sensitive payloads/results; set key TTLs.
Celery: JSON only (accept_content=['json']), no pickle; limit worker concurrency; separate queues for webhooks vs sends; dead‑letter on poison messages.
Kafka: TLS + SASL/SCRAM; topic ACLs; keep PII out of events or encrypt fields; tight retention (7–14d) + compaction where safe.
Elasticsearch: TLS + auth; private network; never internet‑exposed; role‑based indices.
S3/Object storage: Private buckets; deny public ACLs; default SSE‑KMS; presigned URLs with short expiry; org‑scoped paths.

6. Compliance & Data Lifecycle
Consent & unsubscribe: mandatory unsubscribe link; suppression list checked on every send.
Data minimization: collect only necessary fields; default short retention for raw events.
User rights: export/delete endpoints; propagate deletes to ES/S3/Kafka sinks.
DPIA/DPA: document data flows; vendor DPAs (ESP, cloud, analytics).
Incident response: runbook, on‑call, breach notification templates.
